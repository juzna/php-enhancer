<?php # DO NOT EDIT THIS FILE. It was generated by LadyPHP.

class Lady{


  # ---------------------------------------------
  # constants
  # ---------------------------------------------
  const REGEX_CODE = '/.*[^<\?|<\?php|\{|\}|\s].*/' ;# some php code on line
  const REGEX_OPEN_TAG = '/^\s*(<\?|<\?php)\s*$/'   ;# <? or <?php
  const REGEX_COMMENT = '/^\s*(#|\/\/).*/'          ;# full line comment
  const REGEX_EMPTY = '/^\s*$/'                     ;# only spaces
  const REGEX_CONTINUE = '/^\s*[&\|\.(->)].*/'      ;# continue from previous line
  const REGEX_CONTINUE_END = '/[&\|\.,\(\[=]\s*$/'  ;# continue to next line
  const REGEX_CLOSING = '/^\s*[\]\)\}]+\s*$/'       ;# closing bracket on line
  const REGEX_OPENING = '/(^[^(]*|.*\))\s*$/'       ;# 'else' is opening
  const REGEX_VARIABLE = '/^[_a-z].*/'              ;# variable name
  const REGEX_CLASS = '/^([A-Z].*|self|parent)$/'   ;# class name
  const REGEX_NOVARIABLE = '/^(false|true|self|parent|null)$/' ;# not variables

  const PRESERVE = 0  ;# preserve code formating and comments
  const STRIP    = 1  ;# strip comments, keep line numbers
  const COMPRESS = 2  ;# compress output code

  const OUTPUT_HEAD = '# DO NOT EDIT THIS FILE. It was generated by LadyPHP.';
  const INDENT_WIDTH = 2;
  static $debug = false;


  # ---------------------------------------------
  # parse
  # convert lady script to php
  # ---------------------------------------------
  static public function parse($source, $shrink = self::PRESERVE){
    $code = $noVar = null;
    $dump = $comment = array();

    # get tokens
    $tokens = token_get_all($source);

    # convert string tokens to arrays
    foreach ($tokens as $n => $token){
      if (!is_array($token)){
        $tokens[$n] = array(null, $token, null);}}
    
    # process tokens
    foreach ($tokens as $n => $token){
      list($name, $string, $line) = $token;

      # convert `fn` to `function`
      if ($name == T_STRING
          && $string == 'fn'){
        $code .= 'function';}

      # add `new` before `Foo()`
      elseif ($name == T_STRING
          && $tokens[$n + 1][1] == '('
          && $tokens[$n - 2][0] != T_NEW
          && $tokens[$n - 1][0] != T_NS_SEPARATOR
          && !preg_match(self::REGEX_VARIABLE, $string)){
        $code .= 'new ' . $string;}

      # add $ to variables
      elseif ($name == T_STRING
          && $tokens[$n + 1][1] != '('
          && $tokens[$n - 1][1] != '->'
          && $tokens[$n - 1][1] != '.'
          && preg_match(self::REGEX_VARIABLE, $string)
          && !preg_match(self::REGEX_NOVARIABLE, $string)){
        $code .= '$' . $string;}

      # convert . to -> or ::
      elseif ($name == null
          && $string == '.'
          && ($tokens[$n - 1][0] != T_WHITESPACE
              || $tokens[$n + 1][0] != T_WHITESPACE)){
        if ($tokens[$n - 1][0] == T_STRING
            && preg_match(self::REGEX_CLASS, $tokens[$n - 1][1])){
          $code .= '::';}
        else{
          $code .= '->';}}

      # convert : to =>
      elseif ($name == null
          && $string == ':'
          && $tokens[$n - 1][0] != T_WHITESPACE){
        $code .= ' =>';}

      # strip comments
      elseif ($name == T_COMMENT){
        $comments[$line - 1] = $string;
        if (substr($string, -1) == "\n"){
          $code .= "\n";}}

      # convert php open tag
      elseif ($name == T_OPEN_TAG){
        $code .= '<?php ';
        if ($line == 1){
          $code .= self::OUTPUT_HEAD;}}

      # just copy
      else{
        $code .= $string;}

      # save token dump
      if (self::$debug){
        $dump[] = $line . ': ' . token_name($name) . ' =  ' . $string;}}

    # lines
    $lines = explode("\n", $code);
    $indent = 0;

    # shrink lines
    $newLineNum = 0;
    foreach ($lines as $n => $line){
      if (!isset($emptyLines[$newLineNum])){
        $emptyLines[$newLineNum] = null;}
      if (preg_match(self::REGEX_CODE, $line)){
        $shrinkedLines[$newLineNum] = $line;
        $newLineNum++;}
      else {
        $emptyLines[$newLineNum] .= $line . "\n";}}
    $shrinkedLines[] = 'true;';
    $lines = $shrinkedLines;

    # edit lines
    foreach ($lines as $n => $line){
      if (preg_match(self::REGEX_CODE, trim($line))
          && !preg_match(self::REGEX_CONTINUE, trim($line))
          && !preg_match(self::REGEX_CONTINUE_END, trim($lines[$n - 1]))){
        
        $indentBefore = $indent;
        $indent = (strlen($line) - strlen(ltrim($line))) / self::INDENT_WIDTH;
        $jump = $indent - $indentBefore;}
      else {
        $jump = 0;}

      # trim spaces
      $spaceBefore = str_repeat(' ', strlen($line) - strlen(ltrim($line)));
      $spaceAfter = str_repeat(' ', strlen($line) - strlen(rtrim($line)));
      $line = trim($line);

      # move ending bracket
      if ($n > 0
          && preg_match(self::REGEX_CLOSING, $line)){
        $lines[$n - 1] .= $line;
        $line = $lines[$n] = '';}

      # add semicolon
      if ($jump <= 0 
          && $n > 0
          && !preg_match(self::REGEX_CONTINUE, $line) # line starting && ||...
          && preg_match(self::REGEX_CODE, $lines[$n - 1])
          && !preg_match(self::REGEX_OPEN_TAG, $lines[$n - 1])
          && !preg_match(self::REGEX_COMMENT, $lines[$n - 1])
          && !preg_match(self::REGEX_CONTINUE_END, $lines[$n - 1])){
        $lines[$n - 1] .= ';';}

      # add opening bracket
      if ($jump > 0 && $n > 0
          && preg_match(self::REGEX_OPENING, $lines[$n - 1])){
         
        if (preg_match(self::REGEX_EMPTY, $lines[$n - 1])) {# bracket was moved
          $lines[$n - 2] = rtrim($lines[$n - 2], ';') . '{';}
        else{
          $lines[$n - 1] .= '{';}}

      # add closing brackets
      if ($jump < 0
          && !preg_match(self::REGEX_CONTINUE_END, $lines[$n - 1])){
        $lines[$n - 1] .= str_repeat('}', -$jump);}

      # add spaces (PRESERVE)
      if ($shrink == self::PRESERVE){
        $line = $spaceBefore . $line . $spaceAfter;}

      # change line
      $lines[$n] = $line;}

    # add empty lines
    foreach ($lines as $n => $line){
      $lines[$n] = $emptyLines[$n] . $lines[$n];}

    # reindex lines
    $lines = explode("\n", implode("\n", $lines));

    # add comments (PRESERVE)
    if ($shrink == self::PRESERVE){
      foreach ($lines as $n => $line){
        if (isset($comments[$n])){
          $lines[$n] = $lines[$n] . rtrim($comments[$n]);}}}

    # trim spaces (STRIP)
    if ($shrink == self::STRIP){
      foreach ($lines as $n => $line){
        $lines[$n] = rtrim($line, ' ');}}

    # format code
    $code = implode("\n", array_slice($lines, 0, -1));

    # minify code (COMPRESS)
    if ($shrink == self::COMPRESS){
      $code = self::compress($code);}

    # output
    if (self::$debug){
      NDebugger::barDump($dump, 'Lady tokens');}
    return $code;}
  

  # ---------------------------------------------
  # parseFile
  # load file and parse it
  # ---------------------------------------------
  static public function parseFile($file, $cacheFile = null, $shrink = self::PRESERVE){
    if ($cacheFile == null){
      return self::parse(file_get_contents($file), $shrink);}
    else{
      if (!is_file($cacheFile) || filemtime($cacheFile) <= filemtime($file)){
        file_put_contents($cacheFile, self::parseFile($file, null, $shrink));}
      file_get_contents($cacheFile);}}
  

  # ---------------------------------------------
  # includeFile
  # parse file and execute it
  # ---------------------------------------------
  static public function includeFile($file, $cacheFile = null, $shrink = self::PRESERVE){
    if ($cacheFile == null){
      return eval('?>' . self::parseFile($file, null, $shrink));}
    else{
      if (!is_file($cacheFile) || filemtime($cacheFile) <= filemtime($file)){
        file_put_contents($cacheFile, self::parseFile($file, null, $shrink));}
      require_once($cacheFile);}}
  
  # ---------------------------------------------
  # testFile
  # ---------------------------------------------
  static public function testFile($file, $shrink = self::PRESERVE){
    $input = file_get_contents($file);
    $output = self::parseFile($file, null, $shrink);
    $pre = '<pre style="max-height:40em;max-width:30em;float:left;overflow:auto;font-size:12px;border:1px solid gray;padding:.2em;background-color:#fafafa">';
    $html = '<div><h3 style="margin:0">' . $file . '</h3>';
    foreach (array($input, $output) as $text){
      $html .= $pre;
      foreach (explode("\n", $text) as $n => $line){
        $html .= sprintf('%3d: %s', $n, htmlspecialchars($line)) . "\n";}
      $html .= '</pre>';}
    $html .= '<hr style="height=0;border:none;clear:both"></div>';
    return $html;}

  # ---------------------------------------------
  # compress
  # strip comments and compress php source
  # ---------------------------------------------
  static public function compress($php){
    if (!defined('T_DOC_COMMENT')){
      define('T_DOC_COMMENT', -1);}
    if (!defined('T_ML_COMMENT')){
      define('T_ML_COMMENT', -1);}

    $space = $output = '';
    $set = '!"#$&\'()*+,-./:;<=>?@[\]^`{|}';
    $set = array_flip(preg_split('//',$set));

    foreach (token_get_all($php) as $token){
      if (!is_array($token)){
        $token = array(0, $token);}

      if (in_array($token[0], array(T_COMMENT, T_ML_COMMENT, T_DOC_COMMENT, T_WHITESPACE))){
        $space = "\n";}
      else{
        if (isset($set[substr($output, -1)]) || isset($set[$token[1]{0}])){
          $space = '';}
        $output .= $space . $token[1];
        $space = '';}}
    return $output;}}

