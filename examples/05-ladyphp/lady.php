<?php /* DO NOT EDIT THIS FILE. It was generated by LadyPHP. */

# LadyPHP - type PHP with elegance
# ================================
# http://github.com/unu/ladyphp
# Unumin 2012 WTFPL
# Everyone is permitted to copy and distribute verbatim
# or modified copies of this license document, and changing
# it is allowed as long as the name is changed.

class Lady{

  # ---------------------------------------------
  # constants
  # ---------------------------------------------
  const ENDING = '; { } ( [ <?';  # do not add ; { } after these
  const CONTINUING = ') ]';       # line is continuing if starts with these
  const JOINING = '&& || & | -> . + - , / * % = ? :';      # joining symbols
  const REGEX_CLASS = ';^([A-Z].*|self|parent)$;';         # it is class
  const REGEX_VAR =   ';^[_a-z].*$;';                      # it is variable
  const REGEX_NOVAR = ';^(false|true|self|parent|null)$;'; # it isn't variable
  const HEAD = '/* DO NOT EDIT THIS FILE. It was generated by LadyPHP. */';

  # flags
  const COMPRESS = 1;  # compress output code
  const NOCACHE  = 2;  # always overwrite cache file

  # ---------------------------------------------
  # parse
  # convert LadyPHP from string to PHP code
  # ---------------------------------------------
  static function parse($source, $flags = 0){
    $source = str_replace("\r", '', $source);
    $tokens = self::tokenize($source);
    $openingBracket = false;
    $closingBrackets = [];

    # process tokens
    foreach ($tokens as $n => $token){
      extract($token, EXTR_OVERWRITE | EXTR_REFS);

      # skip last dummy token
      if ($n > count($tokens) - 2){
        break;}

      # convert 'fn' to 'function'
      if ($str == 'fn'){
        $str = 'function';}

      # convert . to -> or ::
      elseif ($str == '.'
          && (!$hasBlank || !$tokens[$n + 1]['hasBlank'])){
        if (preg_match(self::REGEX_CLASS, $tokens[$n - 1]['str'])){
          $str = '::';}
        else{
          $str = '->';}}

      # convert : to =>
      elseif ($str == ':' && !$hasBlank && !$isLast){
        $str = ' =>';}

      # add $ before variables
      elseif ($type == T_STRING
          && $tokens[$n + 1]['str'] != '('
          && $tokens[$n - 1]['str'] != '->'
          && preg_match(self::REGEX_VAR, $str)
          && !preg_match(self::REGEX_NOVAR, $str)){
        $str = '$' . $str;}

      # add 'new' before 'Foo\Bar()'
      $i = 0;
      while ((($tokens[$n + $i]['type'] == T_STRING
          && preg_match(self::REGEX_CLASS, $tokens[$n + $i]['str']))
          || $tokens[$n + $i]['type'] == T_NS_SEPARATOR)
          && $hasBlank
          && (!$tokens[$n + $i]['hasBlank'] || $i == 0)
          && $tokens[$n - 1]['type'] != T_NEW){
        if ($tokens[$n + $i]['type'] == T_STRING
            && $tokens[$n + $i + 1]['str'] == '('){
          $str = 'new ' . $str;
          break;}
        $i++;}

      # add semicolon and brackets
      if ($isLast
          && !in_array($str, explode(' ', self::JOINING . ' ' . self::ENDING))
          && $type != T_CLOSE_TAG){

        # sort list of closing brackets
        $closingBrackets = array_unique($closingBrackets);
        rsort($closingBrackets);

        # switch block
        $isSwitch = false;
        $i = 0;
        while (isset($tokens[$n - $i]['y'])
            && $tokens[$n - $i]['y'] == $y){
          if (in_array($tokens[$n - $i]['type'], [T_CASE, T_DEFAULT])){
            $isSwitch = true;
            break;}
          $i++;}
        if ($isSwitch){
          $str .= ':';}

        # next line is indented
        elseif ($tokens[$n + 1]['indent'] > $indent){
          # add opening bracket
          if (!in_array($tokens[$n + 1]['str'], explode(' ', self::JOINING . ' ' . self::CONTINUING))){
            $str .= '{';
            $closingBrackets[] = $indent;
            $openingBracket = false;}
          # save opening bracket
          else{
            $openingBracket = $indent;}}

        # line doesn't continue
        elseif (!in_array($tokens[$n + 1]['str'], explode(' ', self::JOINING . ' ' . self::CONTINUING))){
          # there is saved opening bracket
          if ($openingBracket !== false
              && $tokens[$n + 1]['indent'] > $openingBracket){
            $str .= '{';
            $closingBrackets[] = $openingBracket;
            $openingBracket = false;}
          # add semicolon
          else{
            $str .= ';';}}

        # add closing brackets
        if ($indent > $tokens[$n + 1]['indent']){
          while (isset($closingBrackets[0])
              && $closingBrackets[0] >= $tokens[$n + 1]['indent']){
            $str .= '}';
            $closingBrackets = array_slice($closingBrackets, 1);}}}

      # convert php open tags
      if ($type == T_OPEN_TAG){
        $str = '<?php ';
        if ($y == 0){
          $str .= self::HEAD;}}
      if ($type == T_OPEN_TAG_WITH_ECHO){
        $str = '<?php echo ';}

      # save token
      $tokens[$n] = $token;}

    # glue code
    $code = null;
    foreach ($tokens as $token){
      $code .= $token['blank'] . $token['str'];}

    # return (and compress)
    return ($flags & self::COMPRESS) ? self::compress($code) : $code;}

  # ---------------------------------------------
  # tokenize
  # ---------------------------------------------
  static function tokenize($source){
    $tokens = [];
    $blank = null;

    # prepare tokens
    foreach (token_get_all($source) as $n => $token){

      # convert to associative array
      if (is_array($token)){
        $token = ['str' => $token[1], 'type' => $token[0]];}
      else{
        $token = ['str' => $token, 'type' => null];}

      # save whitespaces and comments into tokens
      if (in_array($token['type'], [T_COMMENT, T_DOC_COMMENT, T_WHITESPACE, T_INLINE_HTML])){
        $blank .= $token['str'];}
      else{
        $token['blank'] = $blank;
        $token['hasBlank'] = ($blank != null);
        $blank = null;
        $tokens[] = $token;}}

    # save remaining blank
    $tokens[] = ['str' => null, 'type' => null, 'blank' => $blank, 'isLast' => true];

    # get positions
    foreach ($tokens as $n => $token){
      $token['n'] = $n;
      if ($n == 0){
        $token['indent'] = $token['x'] = $token['y'] = 0;
        $token['isFirst'] = true;}
      else{
        $token['y'] = $tokens[$n - 1]['y'] + count(explode("\n", $tokens[$n - 1]['str'] . $token['blank'])) - 1;
        $token['isFirst'] = $tokens[$n - 1]['isLast'] = ($tokens[$n - 1]['y'] != $token['y']);
        $token['x'] = mb_strlen(array_slice(explode("\n", $token['blank']), -1)[0]);
        $token['x'] += !$token['isFirst'] ? $tokens[$n - 1]['x'] + mb_strlen($tokens[$n - 1]['str']) : null;
        $token['indent'] = $token['isFirst'] ? $token['x'] : $tokens[$n - 1]['indent'];}
      $tokens[$n] = $token;}

    return $tokens;}

  # ---------------------------------------------
  # cacheFile
  # check cacheFile, parse if it's old
  # ---------------------------------------------
  static function cacheFile($file, $cacheFile, $flags = 0){
    if (!is_dir(dirname($cacheFile))){
      mkdir(dirname($cacheFile), 0755, true);}
    if (!is_file($cacheFile) || filemtime($cacheFile) <= filemtime($file) || $flags & self::NOCACHE){
      file_put_contents($cacheFile, self::parseFile($file, null, $flags));}
    return $cacheFile;}

  # ---------------------------------------------
  # parseFile
  # load file and parse it
  # ---------------------------------------------
  static function parseFile($file, $cacheFile = null, $flags = 0){
    if ($cacheFile){
      return file_get_contents(self::cacheFile($file, $cacheFile, $flags));}
    else{
      return self::parse(file_get_contents($file), $flags);}}

  # ---------------------------------------------
  # includeFile
  # parse file and execute it
  # ---------------------------------------------
  static function includeFile($file, $cacheFile = null, $flags = 0){
    if ($cacheFile){
      return require_once(self::cacheFile($file, $cacheFile, $flags));}
    else{
      return eval('?>' . self::parseFile($file, null, $flags));}}

  # ---------------------------------------------
  # testFile
  # parse file and show input and output as html
  # ---------------------------------------------
  static function testFile($file, $flags = 0){
    $input = file_get_contents($file);
    $output = self::parseFile($file, null, $flags);
    $pre = '<pre style="max-height:40em;max-width:30em;float:left;overflow:auto;font-size:12px;border:1px solid gray;padding:.2em;background-color:#fff">';
    $html = '<div><h3 style="margin:0">' . $file . '</h3>';
    foreach ([$input, $output] as $text){
      $html .= $pre;
      foreach (explode("\n", $text) as $n => $line){
        $html .= sprintf('%3d: %s', $n, htmlspecialchars($line)) . "\n";}
      $html .= '</pre>';}
    return $html . '<hr style="height=0;border:none;clear:both"></div>';}

  # ---------------------------------------------
  # compress
  # remove comments and whitespaces from PHP code
  # ---------------------------------------------
  static function compress($php){
    $space = $output = null;
    $set = array_flip(preg_split('//', '!"#$&\'()*+,-./:;<=>?@[\]^`{|}'));
    foreach (token_get_all($php) as $token){
      if (!is_array($token)){
        $token = [0, $token];}
      if (in_array($token[0], [T_COMMENT, T_DOC_COMMENT, T_WHITESPACE])){
        $space = "\n";}
      else{
        if (isset($set[substr($output, -1)]) || isset($set[$token[1]{0}])){
          $space = null;}
        $output .= $space . $token[1];
        $space = null;}}
    return $output;}}
